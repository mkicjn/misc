;; uKanren using pointer equality comparisons only for variables, i.e., not using numbers at all

;; Supporting non-Kanren definitions

(defun (pair? x) (not (atom x)))

; Thunks / lazy evaluation

(defmacro (delay x) (` lambda () , x))
(defmacro (force x) (` , x))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	uKanren
;;

; A logic variable is a pair where the head is the symbol `_` and the tail is anything else
(defun (logic-var x) (cons '_ x))
(defun (logic-var? x) (and (pair? x) (eq (car x) '_)))

; `walk` - gets the binding of a variable `v` by following a chain of substitutions `s`
(defun (walk v s)
  (cond ((not (logic-var? v)) v)
	(t (let ((b (assoc v s)))
	     (cond (b (walk (cdr b) s))
		   (t v))))))

; `occurs?` - checks if a variable `v` already exists within some object `x` in a chain of substitutions `s`
(defun (occurs? v x s)
  (let ((x (walk x s)))
    (cond
      ((logic-var? x) (eq v x))
      ((pair? x)
       (or (occurs? v (car x) s)
	   (occurs? v (cdr x) s)))
      (t ()))))

; `ext-s` - extends a substitution list `s` with a new binding for a variable `v` to something `x`
(defun (ext-s v x s)
  (cond ((occurs? v x s) ()) ; prohibit circularities
	(t (cons (cons v x) s))))

; `unify` - attempts to extend a substitution list `s` to make one structure `a` identical to another `b`
(defun (unify a b s)
  (let ((a (walk a s)) (b (walk b s)))
    (cond
      ((eq a b) s)
      ((logic-var? a) (ext-s a b s))
      ((logic-var? b) (ext-s b a s))
      ((and (pair? a) (pair? b))
       (let ((s1 (unify (car a) (car b) s)))
	 (and s1 (unify (cdr a) (cdr b) s1))))
      (t ()))))

; The empty stream is an empty list
(define mzero ())
; A substitution list can be lifted into a stream by putting it in a list
(defun (unit s) (cons s mzero))
; Streams can also be promises, which are nullary functions that return a stream
(defun (promise? x) (eq (caar x) 'lambda))
; The initial state to start evaluating a toplevel goal from is the empty list
(define init-state ())

; `==` - constructs a goal unifying a and b
; Note: A goal is a function from a substitution list to a stream of other valid substitution lists
; A goal "succeeds" (or "holds") if it returns a stream of one or more (modified) substitution lists and "fails" otherwise.
(defun (== a b)
  (lambda (s)
    (let ((s1 (unify a b s)))
      (cond (s1 (unit s1))
	    (t mzero)))))

; `call/fresh` - calls a goal with a fresh (unbound) logic variable
(defun (call/fresh f) (f (logic-var ())))

; `disj2` - constructs a goal which forms a logical disjunction by combining the streams generated by two other goals, `g1` and `g2`, upon succeeding
(defun (disj2 g1 g2)
  (lambda (s)
    (mplus (g1 s) (g2 s))))

; `conj2` - constructs a goal which forms a logical conjunction by running one goal, `g2`, on the stream of results from another goal, `g1`
(defun (conj2 g1 g2)
  (lambda (s)
    (bind g2 (g1 s))))

; `mplus` - combines two streams of results, `s1` and `s2`, by performing a list append or executing promises as applicable
(defun (mplus s1 s2)
  (cond ((not s1) s2)
	((promise? s1) (delay (mplus s2 (force s1)))) ; continue from s2 in case s1 is infinite
	(t (cons (car s1) (mplus (cdr s1) s2)))))

; `bind` - executes a goal `g` on each element of a stream `s`, forming another stream of substitutions returned by the goal succeeding
(defun (bind g s)
  (cond ((not s) ())
	((promise? s) (delay (bind g (force s))))
	(t (mplus (g (car s)) (bind g (cdr s))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (End of uKanren core)
;;

; `recons` - reconstruct a (flat) list using a given function
(defun (recons f l)
  (cond ((not l) ())
	(t (f (car l) (recons f (cdr l))))))


;; Easier goal construction via `conde` and `fresh

; Variadic `conj`/`disj` - reconstruct the list of goals by chaining their dyadic forms
(defmacro (conj . args)
  (recons (lambda (a d) (or (and d (` conj2 , a , d)) a)) args))

(defmacro (disj . args)
  (recons (lambda (a d) (or (and d (` disj2 , a , d)) a)) args))

; `conde` - form a disjunction between lists of conjoined goals
(defmacro (conde . ls)
  (let ((do-conj (lambda (l) (` conj ,. l)))
	(do-disj (lambda (l) (` disj ,. l))))
    (do-disj (map do-conj ls))))


; `fresh1` - construct a goal with a single fresh variable
(defmacro (fresh1 arg body)
  (` call/fresh (lambda (, arg) , body)))

; `fresh` - construct a goal with multiple fresh variables by chaining fresh1
(defmacro (fresh args . body)
  (recons (lambda (a d) (` fresh1 , a , (or d (` conj ,. body)))) args))


;; Easier goal definition and execution via `relation` and `run*`

; `take*` - take all elements from a stream and construct a list out of them
(defun (take* s)
  (cond ((promise? s) (take* (force s)))
	((atom s) s)
	(t (cons (car s) (take* (cdr s))))))

; `relation` - shortcut for constructing a goal which is delayed to permit recursion
(defmacro (relation args body)
  (` lambda , args
     (lambda (s)
       (delay (, body s)))))

; `reify` - reconstruct a variable from values in a substitution list
(defun (reify v s)
  (let ((v (walk v s)))
    (cond ((atom v) v)
	  (t (cons (reify (car v) s) (reify (cdr v) s))))))

; `reify-targets` - create logic variables for a list of arguments
(defun (reify-targets args)
  (cond ((not args) ())
	(t (cons (logic-var (car args)) (reify-targets (cdr args))))))

; `run*` - execute a goal `body` with multiple variables `args` from scratch and reify the arguments from every result
(defmacro (run* args body)
  (` let ((targets (reify-targets (quote , args))))
     (map (curry reify targets)
	  (take* (((relation , args , body) . targets) init-state)))))


;; Testing with the canonical example, `appendo`

(define appendo
  (relation (as bs as-bs)
	    (conde ((== as ()) (== bs as-bs))
		   ((fresh (a s s-bs)
			   (== as (cons a s))
			   (== as-bs (cons a s-bs))
			   (appendo s bs s-bs))))))

; (Repeated with quotes just to make ukanren_demo.sh show some extra info)
'(define appendo
  (relation (as bs as-bs)
	    (conde ((== as ()) (== bs as-bs))
		   ((fresh (a s s-bs)
			   (== as (cons a s))
			   (== as-bs (cons a s-bs))
			   (appendo s bs s-bs))))))
appendo
'(run* (a b) (appendo a b '(A B C D E F G)))
(run* (a b) (appendo a b '(A B C D E F G)))

;; Finally, giving in and using numbers just to limit the number of results we get

; `take` - take a certain number `n` of elements from a stream `s` and construct a list out of them
(defun (take n s)
  (cond ((= n 0) ())
	((promise? s) (take n (force s)))
	((atom s) s)
	(t (cons (car s) (take (- n 1) (cdr s))))))

; `run` - execute a goal `body` with multiple variables `args` from scratch and reify the arguments from a certain number `n` of the results
(defmacro (run n args body)
  (` let ((targets (reify-targets (quote , args))))
     (map (curry reify targets)
	  (take , n (((relation , args , body) . targets) init-state)))))

;; Testing it on the most general query of `appendo`

; (Repeated with quotes just to make ukanren_demo.sh show some extra info)
'(run 5 (a b l) (appendo a b l))
(run 5 (a b l) (appendo a b l))
